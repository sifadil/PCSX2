
==================================
-/-   DMAC Hardware Overview   -/-
==================================

Generally speaking, the actual hardware emulation of the DMAC isn't going to be important.
This is because the DMAC is a multi-peripheral interface with FIFOs attached to each
peripheral, and the EE is a multi-threaded environment with exception and interrupt handlers.
So in order to do safe DMA arbitration, programs can make few assumptions about how long
a DMA takes to complete or about DMA status even after starting a transfer immediately.
However, understanding the DMAC hardware can help understand what games are trying to do
with their DMAC registers.

The DMAC works by loading/draining FIFOs attached to each peripheral from/to main memory
using a BURST transfer.  That is, Main Memory -> FIFO is a burst, and then the peripheral
drains the FIFO at its internal bus speed.

Most peripherals (except SPR) operate at half the main bus speed, and incur additional
penalties depending on what's being fed to/from them (the gs for example has several commands
that have 1 cycle penalties).  The SIF transfers are especially slow since the IOP DMAs are
a mere 1/16th fraction the speed of the EE's.  Thus, in order to maximize bus speed its
*always* best to have two or more DMAs running concurrently.  The DMAC will slice between
the DMAs accordingly, filling and draining FIFOs as needed, all while the FIFOs are being
filled/drained by the attached peripherals *in parallel.*

SPR is the Exception!  SPR DMAs can max out the DMAC bandwidth, and as such the toSPR and
fromSPR DMAs are always BURST mode for the entire duration of their transfers, since the
DMAC would have no performance benefit from slicing them with other FIFO-based DMA transfers.


=======================================
-/-   DMAC_ENABLER / DMAC_ENABLEW   -/-
=======================================
	
These registers regulate the master DMAC transfer status for all DMAs.  On the real hardware
it acts as an immediate stoppage of all DMA activity, so that all hardware register accesses
by DMAC are suspended and the EE is allowed to safely write to DMA registers, without the
possibility of DMAC register writebacks interfering with results (DMAC and EE are concurrent
processes, and if both access a register at the same time, either of their writes could be
ignored and tracewarn in rather unpredictable behavior).

Chances are, the real hardware uses the upper 16 bits of this register to store some status
info needed to safely resume the DMA transfer where it left off.  This would explain why it
has separate read and write register addresses, which would allow for concurrent-safe reads
and writes.  It may use the bottom bits as well, or they may be some sort of safety check ID.
PS2 BIOS seems to expect the bottom 16 bits to always be 0x1201, according to code comments
found in HW.cpp.

In any case, our DMAC is *not* a concurrent process, and all our status vars are already
in order (mostly stored in DMA registers) so there isn't much we need to do except adhere
to the program's wishes and suspend all transfers. :)

Note: ENABLEW is a write-to reg only, and it automatically updates DMAC_ENABLER when handled
from the indirect memop handlers.


=========================
-/-   Stall Control   -/-
=========================

The DMAC stall control consists of the Source channel (STS), which simply updated STADR as it
processes and transfers data; and the Drain channel (STD), which requires more complicated
logic that checks the STADR prior to each copy to ensure that it does not process data beyond
the STS channel.

The STADR can also be modified freely by PS2 apps on-the-fly, allowing them to do manual
stall control if they so please (done by having a valid STD setting and STS set to zero).

The most important aspect to remember is that Stall Control Destination functionality can 
result in a DMA request being completely disregarded: if the stall condition is met when the
DMA is started (STR=1), the transfer will be disregarded (apparently).



=========================
-/-   MFIFO Details   -/-
=========================

The MFIFO is a pretty funky little thing, with quite a few specific rules:

1. Source channel is fromSPR.
  1a. ... and it MUST be in NORMAL mode (logical transfer mode).

2. Drain channel can be either VIF1 or GIF 
  2a. ... and it MUST be in SOURCE CHAIN mode (logical transfer mode).
  2b. ... and the only valid tags are CNT, END, REF, REFS, REFE.

3. fromSpr.MADR becomes the ringbuffer "writepos" and Dn.TADR becomes the ringbuffer "readpos"
  3a. when (fromSpr.MADR == Dn.TADR) the ringbuffer is empty and the drain channel stalls.

4. fromSPR transfers in BURSTs based on the source chain packet sizes (tag + QWC), which
   is why the drain channel must be in CHAIN mode.  Because of this, it would be a serious
   error to pass non-CHAIN data through fromSPR (likely causing deadlock).

5. MEIS occurs when fromSPR.STR == 0 and drain channel empties the MFIFO (by rule 3a above).
   It appears MEIS is based on Dn.MADR, rather than Dn.TADR, as based on the following
   known conditions:
  
  5a. MEIS is only detected on CNT tags, and is *not* detected on REF-type tags.
  5b. ... thus MEIS should not raised if the MFIFO empties itself on a REFx tag.
  5c. MEIS is raised properly on incomplete END/CNT tags (ie, tag has a QWC of 50 but
      fromSPR.QWC is only 30).

======================================
-/-   Transfer Tag Enable (TTE=1)  -/-
======================================

TTE is available in source Chain mode only, and when enabled it transfers the QWC containing
the DMAtag along with the data.

The TTE doesn't really do what we might initially think.  First off, tansferring the DMAtag
itself (the lower 64 bits) is typically a recipe for disaster: if sent to the VIF code
or GIF tag parsers, it would end up being who-knows-what tag!  But on the other hand the
DMAC can't just send the upper 64 bits of the tag either; it has strict QWC-only limitations.
So what it *really* does, as best as we can tell, is mask the lower 64 bits of the tag to
zero and upload the masked QWC to the destination peripheral.

This works nicely since zeros are NOPs on both VIFcode and GIFtag parsers.  So it allows
the DMAC to operate efficiently, while doing nothing more than dumping a pair of harmless
zeros into the target peripherals.

The PS2 engineers' rational for implementing the TTE is due to how the EE's RAM is configured,
how the DMAC interfaces with EE RAM, and due to the DMAC's slice transfer behavior.

The DMAC operates most efficiently when it starts at 128-byte (8 QWC) boundaries in memory
and can increment the bottom 3 bits of its transfer src/dest address sequentially.  Note
that the upper bits are not relevant to DMAC performance!  It can hop around in memory
(via REF tags) all it wants, so long as the internal read alignment remains consistent.
Thus, TTE was introduced, since TTE=1 is usually ideal for CNT tags and TTE=0 is usually
ideal for REF tags.

(... and mixing REF and CNT tags is generally no recommended ;)

Since the only real purpose of TTE is to allow source chain transfers to pad their transfers
with zeros, so to applease the DMAC's preferences for QWC alignment, its reasonable to 
assume that the hardware simply masks the value before witing the result.

** Confirming TTE Behavior **

 * TTE can be confirmed easily using toSPR's Source Chain mode transfer.  Write dummy
   data to SPR memory, initiate a simple chain transfer wih TTE=1, and read back the
   result.
