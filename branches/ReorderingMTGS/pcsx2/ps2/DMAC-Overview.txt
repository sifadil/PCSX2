
==================================
-/-   DMAC Hardware Overview   -/-
==================================

Generally speaking, the actual hardware emulation of the DMAC isn't going to be important.
This is because the DMAC is a multi-peripheral interface with FIFOs attached to each
peripheral, and the EE is a multi-threaded environment with exception and interrupt handlers.
So in order to do safe DMA arbitration, programs can make few assumptions about how long
a DMA takes to complete or about DMA status even after starting a transfer immediately.
However, understanding the DMAC hardware can help understand what games are trying to do
with their DMAC registers.

The DMAC works by loading/draining FIFOs attached to each peripheral from/to main memory
using a BURST transfer.  That is, Main Memory -> FIFO is a burst, and then the peripheral
drains the FIFO at its internal bus speed.

Most peripherals (except SPR) operate at half the main bus speed, and incur additional
penalties depending on what's being fed to/from them (the gs for example has several commands
that have 1 cycle penalties).  The SIF transfers are especially slow since the IOP DMAs are
a mere 1/16th fraction the speed of the EE's.  Thus, in order to maximize bus speed its
*always* best to have two or more DMAs running concurrently.  The DMAC will slice between
the DMAs accordingly, filling and draining FIFOs as needed, all while the FIFOs are being
filled/drained by the attached peripherals *in parallel.*

SPR is the Exception!  SPR DMAs can max out the DMAC bandwidth, and as such the toSPR and
fromSPR DMAs are always BURST mode for the entire duration of their transfers, since the
DMAC would have no performance benefit from slicing them with other FIFO-based DMA transfers.


=========================
-/-   MFIFO Details   -/-
=========================

The MFIFO is a pretty funky little thing, with quite a few specific rules:

1. Source channel is fromSPR.
  1a. ... and it MUST be in NORMAL mode (logical transfer mode).

2. Drain channel can be either VIF1 or GIF 
  2a. ... and it MUST be in SOURCE CHAIN mode (logical transfer mode).
  2b. ... and the only valid tags are CNT, END, REF, REFS, REFE.

3. fromSpr.MADR becomes the ringbuffer "writepos" and Dn.TADR becomes the ringbuffer "readpos"
  3a. when (fromSpr.MADR == Dn.TADR) the ringbuffer is empty and the drain channel stalls.

4. fromSPR transfers in BURSTs based on the source chain packet sizes (tag + QWC), which
   is why the drain channel must be in CHAIN mode.  Because of this, it would be a serious
   error to pass non-CHAIN data through fromSPR (likely causing deadlock).

5. MEIS occurs when fromSPR.STR == 0 and drain channel empties the MFIFO (by rule 3a above).
   It appears MEIS is based on Dn.MADR, rather than Dn.TADR, as based on the following
   known conditions:
  
  5a. MEIS is only detected on CNT tags, and is *not* detected on REF-type tags.
  5b. ... thus MEIS should not raised if the MFIFO empties itself on a REFx tag.
  5c. MEIS is raised properly on incomplete END/CNT tags (ie, tag has a QWC of 50 but
      fromSPR.QWC is only 30).

======================================
-/-   Transfer Tag Enable (TTE=1)  -/-
======================================

TTE is available in source Chain mode only, and when enabled it transfers the QWC containing
the DMAtag along with the data.

The TTE doesn't really do what we might initially think.  First off, tansferring the DMAtag
itself (the lower 64 bits) is typically a recipe for disaster: if sent to the VIF code
or GIF tag parsers, it would end up being who-knows-what tag!  But on the other hand the
DMAC can't just send the upper 64 bits of the tag either; it has strict QWC-only limitations.
So what it *really* does, as best as we can tell, is mask the lower 64 bits of the tag to
zero and upload the masked QWC to the destination peripheral.

This works nicely since zeros are NOPs on both VIFcode and GIFtag parsers.  So it allows
the DMAC to operate efficiently, while doing nothing more than dumping a pair of harmless
zeros into the target peripherals.

The PS2 engineers' rational for implementing the TTE is due to how the EE's RAM is configured,
how the DMAC interfaces with EE RAM, and due to the DMAC's slice transfer behavior.

The DMAC operates most efficiently when it starts at 128-byte (8 QWC) boundaries in memory
and can increment the bottom 3 bits of its transfer src/dest address sequentially.  Note
that the upper bits are not relevant to DMAC performance!  It can hop around in memory
(via REF tags) all it wants, so long as the internal read alignment remains consistent.
Thus, TTE was introduced, since TTE=1 is usually ideal for CNT tags and TTE=0 is usually
ideal for REF tags.

(... and mixing REF and CNT tags is generally no recommended ;)

Since the only real purpose of TTE is to allow source chain transfers to pad their transfers
with zeros, so to applease the DMAC's preferences for QWC alignment, its reasonable to 
assume that the hardware simply masks the value before witing the result.

** Confirming TTE Behavior **

 * TTE can be confirmed easily using toSPR's Source Chain mode transfer.  Write dummy
   data to SPR memory, initiate a simple chain transfer wih TTE=1, and read back the
   result.
